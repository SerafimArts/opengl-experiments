#!/usr/bin/env php
<?php

/**
 * This file is part of Cube package.
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

declare(strict_types=1);

use App\Library\GLFW3;
use App\Library\GL;
use FFI\Scalar\Type;
use Symfony\Component\Console\Output\ConsoleOutput;

require __DIR__ . '/vendor/autoload.php';

$gl = new GL();
$glfw = new GLFW3();
$output = new ConsoleOutput();

// ====================
const WIDTH  = 640;
const HEIGHT = 480;
const MSAA   = 4;
const VSYNC  = false;
// ====================

$vertexShaderSource = Type::stringArray([<<<'GLSL'
#version 330 core

layout (location = 0) in vec3 aPos;

void main() {
   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);
}
GLSL]);

$fragmentShaderSource = Type::stringArray([<<<'GLSL'
#version 330 core

out vec4 FragColor;

void main() {
   FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);
}
GLSL]);


$glfw->glfwSetErrorCallback(static function (int $code, string $message) use ($output) {
    $output->writeln(\sprintf('<error>[0x%h] %s</error>', $code, $message));
});

// glfw: initialize and configure
// ------------------------------
$glfw->glfwInit();
MSAA and $glfw->glfwWindowHint(GLFW3::SAMPLES, MSAA);
$glfw->glfwWindowHint(GLFW3::CONTEXT_VERSION_MAJOR, 4);
$glfw->glfwWindowHint(GLFW3::CONTEXT_VERSION_MINOR, 6);
$glfw->glfwWindowHint(GLFW3::OPENGL_PROFILE, GLFW3::OPENGL_CORE_PROFILE);

PHP_OS_FAMILY === 'Darwin'
    and $glfw->glfwWindowHint(GLFW3::OPENGL_FORWARD_COMPAT, GLFW3::TRUE);

// glfw window creation
// --------------------
$window = $glfw->glfwCreateWindow(WIDTH, HEIGHT, "PHP Rocks!", null, null);
$glfw->glfwSetFramebufferSizeCallback($window, function (mixed $window, int $width, int $height) use ($gl): void {
    $gl->glViewport(0, 0, $width, $height);
});
$glfw->glfwMakeContextCurrent($window);
$glfw->glfwSwapInterval((int)VSYNC);

$output->writeln('Renderer: <comment>' . $gl->glGetString(GL::RENDERER) . '</comment>');
$output->writeln('Version: <comment>' . $gl->glGetString(GL::VERSION) . '</comment>');

// build and compile our shader program
// ------------------------------------

// vertex shader
$vertexShader = $gl->glCreateShader(GL::VERTEX_SHADER);
$gl->glShaderSource($vertexShader, 1, FFI::addr($vertexShaderSource[0]), null);
$gl->glCompileShader($vertexShader);
// check for shader compile errors
$success = Type::int();
$gl->glGetShaderiv($vertexShader, GL::COMPILE_STATUS, FFI::addr($success));
if (!$success->cdata) {
    $gl->glGetShaderInfoLog($vertexShader, 512, null, $message = FFI::new('char[512]'));
    throw new \LogicException(FFI::string($message));
}

// fragment shader
$fragmentShader = $gl->glCreateShader(GL::FRAGMENT_SHADER);
$gl->glShaderSource($fragmentShader, 1, FFI::addr($fragmentShaderSource[0]), null);
$gl->glCompileShader($fragmentShader);
// check for shader compile errors
$gl->glGetShaderiv($fragmentShader, GL::COMPILE_STATUS, FFI::addr($success));
if (!$success->cdata) {
    $gl->glGetShaderInfoLog($fragmentShader, 512, null, $message = FFI::new('char[512]'));
    throw new \LogicException(FFI::string($message));
}

// link shaders
$shaderProgram = $gl->glCreateProgram();
$gl->glAttachShader($shaderProgram, $vertexShader);
$gl->glAttachShader($shaderProgram, $fragmentShader);
$gl->glLinkProgram($shaderProgram);

// check for linking errors
$gl->glGetShaderiv($fragmentShader, GL::LINK_STATUS, FFI::addr($success));
if (!$success->cdata) {
    $gl->glGetShaderInfoLog($fragmentShader, 512, null, $message = FFI::new('char[512]'));
    throw new \LogicException(FFI::string($message));
}

$gl->glDeleteShader($vertexShader);
$gl->glDeleteShader($fragmentShader);

// set up vertex data (and buffer(s)) and configure vertex attributes
// ------------------------------------------------------------------
$vertices = Type::floatArray([
     0.5,  0.5, 0.0,  // top right
     0.5, -0.5, 0.0,  // bottom right
    -0.5, -0.5, 0.0,  // bottom left
    -0.5,  0.5, 0.0,  // top left
]);

$indices = Type::uint32Array([  // note that we start from 0!
    0, 1, 3,  // first Triangle
    1, 2, 3,  // second Triangle
]);

[$vbo, $vao, $ebo] = [Type::uint32(), Type::uint32(), Type::uint32()];
$gl->glGenVertexArrays(1, FFI::addr($vao));
$gl->glGenBuffers(1, FFI::addr($vbo));
$gl->glGenBuffers(1, FFI::addr($ebo));
// bind the Vertex Array Object first, then bind and set vertex buffer(s), and
// then configure vertex attributes(s).
$gl->glBindVertexArray($vao->cdata);

$gl->glBindBuffer(GL::ARRAY_BUFFER, $vbo->cdata);
$gl->glBufferData(GL::ARRAY_BUFFER, FFI::sizeof($vertices), $vertices, GL::STATIC_DRAW);

$gl->glBindBuffer(GL::ELEMENT_ARRAY_BUFFER, $ebo->cdata);
$gl->glBufferData(GL::ELEMENT_ARRAY_BUFFER, FFI::sizeof($indices), $indices, GL::STATIC_DRAW);

$gl->glVertexAttribPointer(0, 3, GL::FLOAT, GL::FALSE, 3 * FFI::sizeof(FFI::type('float')), null);
$gl->glEnableVertexAttribArray(0);

// note that this is allowed, the call to glVertexAttribPointer registered VBO
// as the vertex attribute's bound vertex buffer object so afterwards we can safely unbind
$gl->glBindBuffer(GL::ARRAY_BUFFER, 0);

// remember: do NOT unbind the EBO while a VAO is active as the bound element
// buffer object IS stored in the VAO; keep the EBO bound.
//glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);

// You can unbind the VAO afterwards so other VAO calls won't accidentally modify
// this VAO, but this rarely happens. Modifying other
// VAOs requires a call to glBindVertexArray anyways so we generally don't unbind
// VAOs (nor VBOs) when it's not directly necessary.
$gl->glBindVertexArray(0);

$gl->glPolygonMode(GL::FRONT_AND_BACK, GL::LINE);

[$fps, $time] = [0, microtime(true)];
while (!$glfw->glfwWindowShouldClose($window)) {
    ++$fps;

    $now = microtime(true);
    $delta = $now - $time;
    if ($delta > 0.1) {
        $fps *= 1 / $delta;
        $glfw->glfwSetWindowTitle($window, 'FPS ' . (int)$fps);
        [$time, $fps] = [$now, 0];
    }

    // input
    // -----
    if ($glfw->glfwGetKey($window, GLFW3::KEY_ESCAPE) === GLFW3::PRESS) {
        $glfw->glfwSetWindowShouldClose($window, 1);
    }

    // render
    // ------
    $gl->glClearColor(0.2, 0.3, 0.3, 1.0);
    $gl->glClear(GL::COLOR_BUFFER_BIT);

    // draw our first triangle
    $gl->glUseProgram($shaderProgram);
    $gl->glBindVertexArray($vao->cdata); // seeing as we only have a single VAO
                                         // there's no need to bind it every time,
                                         // but we'll do so to keep things a bit
                                         // more organized
    // glDrawArrays(GL_TRIANGLES, 0, 6);
    $gl->glDrawElements(GL::TRIANGLES, 6, GL::UNSIGNED_INT, null);
    // glBindVertexArray(0); // no need to unbind it every time

    // glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.)
    // -------------------------------------------------------------------------------
    $glfw->glfwSwapBuffers($window);
    $glfw->glfwPollEvents();
}

// optional: de-allocate all resources once they've outlived their purpose:
// ------------------------------------------------------------------------
$gl->glDeleteVertexArrays(1, FFI::addr($vao));
$gl->glDeleteBuffers(1, FFI::addr($vbo));
$gl->glDeleteBuffers(1, FFI::addr($ebo));
$gl->glDeleteProgram($shaderProgram);

// glfw: terminate, clearing all previously allocated GLFW resources.
// ------------------------------------------------------------------
$glfw->glfwTerminate();
